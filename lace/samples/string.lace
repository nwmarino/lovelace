load "mem.lace";

$[public, intrinsic]
string :: struct {
    data: mut *mut char,
    len: mut u32,
}

/// Create a new, empty string.
$public
string_new :: () -> string {
    let str: string;
    str.data = null;
    str.len = 0;
    ret str;
}

/// Create a new string from an existing character array |s|.
$public
string_create :: (s: *char) -> string {
    // $assert(s && ...);

    let len: mut u32 = 0;
    until s[len] == '\0' {
        len = len + 1;
    }

    let str: string;
    str.data = mem_alloc(len + 1);
    // $assert(str.data && ...);
    
    mem_copy(str.data, s, len);
    str.data[len] = '\0';
    str.len = len;
    ret str;
}

/// Destroy a string.
$public
string_destroy :: (str: string) -> void {
    mem_free(str.data);
    str.data = null;
    str.len = 0;
}

/// Returns the length of the given string.
$public
string_len :: (str: string) -> u32 {
    ret str.len;
}

/// Test if the given string is empty, i.e. contains no characters.
$public
string_empty :: (str: string) -> bool {
    ret str.len == 0;
}

/// Get the character at position |i| of the given |str|.
$public
string_at :: (str: string, i: u32) -> char {
    // $assert(i < str.len && ...)
    ret str.data[i];
}

/// Compare two strings for equality.
$public
string_eq :: (str: string, other: string) -> bool {
    if str.len != other.len {
        ret false;
    }

    let i: mut u32 = 0;
    until i >= str.len {
        if str.data[i] != other.data[i] {
            ret false;
        }

        i = i + 1;
    }

    ret true;
}

/// Append the contents of |other| to the end of |str|.
$public
string_append :: (str: string, other: string) -> void {
    let new_len: u32 = str.len + other.len;
    if new_len <= str.len {
        ret;
    }

    let new_data: *mut char = mem_alloc(new_len + 1);
    // $assert(new_data && ...);

    mem_copy(new_data, str.data, str.len);
    mem_copy(new_data + str.len, other.data, other.len);
    new_data[new_len] = '\0';

    mem_free(str.data);

    str.data = new_data;
    str.len = new_len;
}
