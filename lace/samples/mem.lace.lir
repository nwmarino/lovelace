LIR_CONTROL_FLOW_GRAPH "/home/statim/lace/samples/mem.lace"

Metadata :: { i64, *Metadata, i8 }

@border := internal **void null
@head := internal **Metadata null

brk :: external (i64) -> *void;

close :: external (i64) -> i64;

exit :: external (i64) -> void;

extend_heap :: internal (inc: i64) -> *void {
	inc := i64 |8
	new_border := *void |8
	old_border := *void |8
bb0:
	store inc: i64, inc: *i64
	$110 = load @border: **void |8
	$111 = cmp ine $110: *void, null
	jif $111: i1, bb1, bb4
bb1:
	$112 = call fetch_border: *void ()
	$113 = load @border: **void |8
	$114 = cmp ine $113: *void, null
	jif $114: i1, bb2, bb3
bb2:
	$115 = i2p (*void) -1: i64
	ret $115: *void
bb3:
	jmp bb4
bb4:
	$116 = load inc: *i64 |8
	$117 = cmp ieq $116: i64, 0: i64
	jif $117: i1, bb5, bb6
bb5:
	$118 = load @border: **void |8
	ret $118: *void
bb6:
	$119 = load @border: **void |8
	store $119: *void, old_border: **void
	$120 = load @border: **void |8
	$121 = reint (*i8) $120: *void
	$122 = load inc: *i64 |8
	$123 = pwalk $121: *i8, $122: i64
	$124 = reint (*void) $123: *i8
	store $124: *void, new_border: **void
	$125 = load new_border: **void |8
	$126 = p2i (i64) $125: *void
	$127 = call brk: *void ($126: i64)
	$128 = load old_border: **void |8
	$129 = cmp ieq $127: *void, $128: *void
	jif $129: i1, bb7, bb8
bb7:
	$130 = i2p (*void) -1: i64
	ret $130: *void
bb8:
	$131 = load new_border: **void |8
	store $131: *void, @border: **void
	$132 = load @border: **void |8
	ret $132: *void
}

fetch_border :: internal () -> *void {
bb0:
	$105 = call brk: *void (0: i64)
	store $105: *void, @border: **void
	$106 = load @border: **void |8
	ret $106: *void
}

find_free_space :: internal (last: **Metadata, size: i64) -> *Metadata {
	curr := *Metadata |8
	last := **Metadata |8
	size := i64 |8
bb0:
	store last: **Metadata, last: ***Metadata
	store size: i64, size: *i64
	$133 = load @border: **void |8
	$134 = reint (*Metadata) $133: *void
	store $134: *Metadata, curr: **Metadata
	jmp bb1
bb1:
	$135 = load curr: **Metadata |8
	$136 = cmp ine $135: *Metadata, null
	jif $136: i1, bb7, bb2
bb2:
	$137 = load curr: **Metadata |8
	$138 = pwalk $137: *Metadata, 0: i32, 2: i32
	$139 = load $138: *i8 |1
	$140 = cmp ine $139: i8, 0: i8
	jif $140: i1, bb3, bb4(0: i1)
bb3:
	$141 = load curr: **Metadata |8
	$142 = pwalk $141: *Metadata, 0: i32, 0: i32
	$143 = load $142: *i64 |8
	$144 = load size: *i64 |8
	$145 = cmp uge $143: i64, $144: i64
	jmp bb4($145: i1)
bb4(p0: i1):
	jif p0: i1, bb5, bb6
bb5:
	jmp bb7
bb6:
	$146 = load last: ***Metadata |8
	$147 = load curr: **Metadata |8
	store $147: *Metadata, $146: **Metadata
	$148 = load curr: **Metadata |8
	$149 = pwalk $148: *Metadata, 0: i32, 1: i32
	$150 = load $149: **Metadata |8
	store $150: *Metadata, curr: **Metadata
	jmp bb1
bb7:
	$151 = load curr: **Metadata |8
	ret $151: *Metadata
}

get_block_pointer :: internal (p: *void) -> *Metadata {
	p := *void |8
bb0:
	store p: *void, p: **void
	$107 = load p: **void |8
	$108 = reint (*Metadata) $107: *void
	$109 = pwalk $108: *Metadata, -1: i64
	ret $109: *Metadata
}

mem_alloc :: external (size: i64) -> *void {
	align := i64 |8
	block := *Metadata |8
	last := *Metadata |8
	size := i64 |8
bb0:
	store size: i64, size: *i64
	store null, block: **Metadata
	$16 = load size: *i64 |8
	store $16: i64, align: *i64
	$17 = load size: *i64 |8
	$18 = umod $17: i64, 16: i64
	$19 = cmp ine $18: i64, 0: i64
	jif $19: i1, bb1, bb2
bb1:
	$20 = load align: *i64 |8
	$21 = iadd $20: i64, 16: i64
	$22 = load size: *i64 |8
	$23 = umod $22: i64, 16: i64
	$24 = isub $21: i64, $23: i64
	store $24: i64, align: *i64
	jmp bb2
bb2:
	$25 = load @head: **Metadata |8
	$26 = cmp ine $25: *Metadata, null
	jif $26: i1, bb3, bb6
bb3:
	$27 = load align: *i64 |8
	$28 = call request_space: *Metadata (null, $27: i64)
	store $28: *Metadata, block: **Metadata
	$29 = load block: **Metadata |8
	$30 = cmp ine $29: *Metadata, null
	jif $30: i1, bb4, bb5
bb4:
	ret null
bb5:
	$31 = load block: **Metadata |8
	store $31: *Metadata, @head: **Metadata
	jmp bb12
bb6:
	$32 = load @head: **Metadata |8
	store $32: *Metadata, last: **Metadata
	$33 = load align: *i64 |8
	$34 = call find_free_space: *Metadata (last: **Metadata, $33: i64)
	store $34: *Metadata, block: **Metadata
	$35 = load block: **Metadata |8
	$36 = cmp ine $35: *Metadata, null
	jif $36: i1, bb7, bb8
bb7:
	$37 = load block: **Metadata |8
	$38 = pwalk $37: *Metadata, 0: i32, 2: i32
	store 0: i8, $38: *i8
	jmp bb11
bb8:
	$39 = load last: **Metadata |8
	$40 = load align: *i64 |8
	$41 = call request_space: *Metadata ($39: *Metadata, $40: i64)
	store $41: *Metadata, block: **Metadata
	$42 = load block: **Metadata |8
	$43 = cmp ine $42: *Metadata, null
	jif $43: i1, bb9, bb10
bb9:
	ret null
bb10:
	jmp bb11
bb11:
	jmp bb12
bb12:
	$44 = load block: **Metadata |8
	$45 = pwalk $44: *Metadata, 1: i64
	$46 = reint (*void) $45: *Metadata
	ret $46: *void
}

mem_copy :: external (dst: *void, src: *void, n: i64) -> void {
	d := *i8 |8
	dst := *void |8
	n := i64 |8
	s := *i8 |8
	src := *void |8
bb0:
	store dst: *void, dst: **void
	store src: *void, src: **void
	store n: i64, n: *i64
	$1 = load dst: **void |8
	$2 = reint (*i8) $1: *void
	store $2: *i8, d: **i8
	$3 = load src: **void |8
	$4 = reint (*i8) $3: *void
	store $4: *i8, s: **i8
	jmp bb1
bb1:
	$5 = load n: *i64 |8
	$6 = cmp ieq $5: i64, 0: i64
	jif $6: i1, bb3, bb2
bb2:
	$7 = load d: **i8 |8
	$8 = load n: *i64 |8
	$9 = pwalk $7: *i8, $8: i64
	$10 = load s: **i8 |8
	$11 = load n: *i64 |8
	$12 = pwalk $10: *i8, $11: i64
	$13 = load $12: *i8 |1
	store $13: i8, $9: *i8
	$14 = load n: *i64 |8
	$15 = isub $14: i64, 1: i64
	store $15: i64, n: *i64
	jmp bb1
bb3:
	ret 
}

mem_free :: external (p: *void) -> void {
	block := *Metadata |8
	p := *void |8
bb0:
	store p: *void, p: **void
	$47 = load p: **void |8
	$48 = cmp ine $47: *void, null
	jif $48: i1, bb1, bb2
bb1:
	ret 
bb2:
	$49 = load p: **void |8
	$50 = call get_block_pointer: *Metadata ($49: *void)
	store $50: *Metadata, block: **Metadata
	$51 = load block: **Metadata |8
	$52 = pwalk $51: *Metadata, 0: i32, 2: i32
	store 1: i8, $52: *i8
	$53 = load block: **Metadata |8
	$54 = pwalk $53: *Metadata, 0: i32, 1: i32
	$55 = load $54: **Metadata |8
	$56 = cmp ine $55: *Metadata, null
	jif $56: i1, bb3, bb6
bb3:
	$57 = load block: **Metadata |8
	$58 = pwalk $57: *Metadata, 0: i32, 1: i32
	$59 = load $58: **Metadata |8
	$60 = pwalk $59: *Metadata, 0: i32, 2: i32
	$61 = load $60: *i8 |1
	$62 = cmp ine $61: i8, 0: i8
	jif $62: i1, bb4, bb5
bb4:
	$63 = load block: **Metadata |8
	$64 = pwalk $63: *Metadata, 0: i32, 0: i32
	$65 = load block: **Metadata |8
	$66 = pwalk $65: *Metadata, 0: i32, 0: i32
	$67 = load $66: *i64 |8
	$68 = load block: **Metadata |8
	$69 = pwalk $68: *Metadata, 0: i32, 1: i32
	$70 = load $69: **Metadata |8
	$71 = pwalk $70: *Metadata, 0: i32, 0: i32
	$72 = load $71: *i64 |8
	$73 = iadd $67: i64, $72: i64
	$74 = iadd $73: i64, 24: i64
	store $74: i64, $64: *i64
	$75 = load block: **Metadata |8
	$76 = pwalk $75: *Metadata, 0: i32, 1: i32
	$77 = load block: **Metadata |8
	$78 = pwalk $77: *Metadata, 0: i32, 1: i32
	$79 = load $78: **Metadata |8
	$80 = pwalk $79: *Metadata, 0: i32, 1: i32
	$81 = load $80: **Metadata |8
	store $81: *Metadata, $76: **Metadata
	jmp bb5
bb5:
	jmp bb6
bb6:
	ret 
}

mem_realloc :: external (p: *void, size: i64) -> *void {
	block := *Metadata |8
	new_p := *void |8
	p := *void |8
	size := i64 |8
bb0:
	store p: *void, p: **void
	store size: i64, size: *i64
	$82 = load p: **void |8
	$83 = cmp ine $82: *void, null
	jif $83: i1, bb1, bb2
bb1:
	$84 = load size: *i64 |8
	$85 = call mem_alloc: *void ($84: i64)
	ret $85: *void
bb2:
	$86 = load p: **void |8
	$87 = call get_block_pointer: *Metadata ($86: *void)
	store $87: *Metadata, block: **Metadata
	$88 = load block: **Metadata |8
	$89 = pwalk $88: *Metadata, 0: i32, 0: i32
	$90 = load $89: *i64 |8
	$91 = load size: *i64 |8
	$92 = cmp uge $90: i64, $91: i64
	jif $92: i1, bb3, bb4
bb3:
	$93 = load p: **void |8
	ret $93: *void
bb4:
	$94 = load size: *i64 |8
	$95 = call mem_alloc: *void ($94: i64)
	store $95: *void, new_p: **void
	$96 = load new_p: **void |8
	$97 = cmp ine $96: *void, null
	jif $97: i1, bb5, bb6
bb5:
	ret null
bb6:
	$98 = load new_p: **void |8
	$99 = load p: **void |8
	$100 = load block: **Metadata |8
	$101 = pwalk $100: *Metadata, 0: i32, 0: i32
	$102 = load $101: *i64 |8
	call mem_copy: void ($98: *void, $99: *void, $102: i64)
	$103 = load p: **void |8
	call mem_free: void ($103: *void)
	$104 = load new_p: **void |8
	ret $104: *void
}

open :: external (*i8, i64, i64) -> i64;

request_space :: internal (last: *Metadata, size: i64) -> *Metadata {
	block := *Metadata |8
	border_meta := *Metadata |8
	last := *Metadata |8
	mem := *void |8
	size := i64 |8
	total_size := i64 |8
bb0:
	store last: *Metadata, last: **Metadata
	store size: i64, size: *i64
	$152 = load size: *i64 |8
	$153 = iadd $152: i64, 24: i64
	store $153: i64, total_size: *i64
	store null, block: **Metadata
	store null, mem: **void
	$154 = string "1
"
	$155 = call write: i64 (1: i64, $154: *i8, 2: i64)
	$156 = call extend_heap: *void (0: i64)
	$157 = reint (*Metadata) $156: *void
	store $157: *Metadata, border_meta: **Metadata
	$158 = string "1
"
	$159 = call write: i64 (1: i64, $158: *i8, 2: i64)
	$160 = load border_meta: **Metadata |8
	store $160: *Metadata, block: **Metadata
	$161 = load total_size: *i64 |8
	$162 = call extend_heap: *void ($161: i64)
	store $162: *void, mem: **void
	$163 = string "1
"
	$164 = call write: i64 (1: i64, $163: *i8, 2: i64)
	$165 = load last: **Metadata |8
	$166 = cmp ine $165: *Metadata, null
	jif $166: i1, bb1, bb2
bb1:
	$167 = load last: **Metadata |8
	$168 = pwalk $167: *Metadata, 0: i32, 1: i32
	$169 = load block: **Metadata |8
	store $169: *Metadata, $168: **Metadata
	jmp bb2
bb2:
	$170 = string "1
"
	$171 = call write: i64 (1: i64, $170: *i8, 2: i64)
	$172 = load block: **Metadata |8
	$173 = pwalk $172: *Metadata, 0: i32, 0: i32
	$174 = load size: *i64 |8
	store $174: i64, $173: *i64
	$175 = load block: **Metadata |8
	$176 = pwalk $175: *Metadata, 0: i32, 1: i32
	store null, $176: **Metadata
	$177 = load block: **Metadata |8
	$178 = pwalk $177: *Metadata, 0: i32, 2: i32
	store 0: i8, $178: *i8
	$179 = load block: **Metadata |8
	ret $179: *Metadata
}

write :: external (i64, *i8, i64) -> i64;
