MemmapFlags :: enum {
    MMAP_FLAGS_FILE = 0,
    MMAP_FLAGS_SHARED = 1,
    MMAP_FLAGS_PRIVATE = 2,
    MMAP_FLAGS_SHARED_VALIDATE = 3,
    MMAP_FLAGS_FIXED = 10,
    MMAP_FLAGS_TYPE = 16,
    MMAP_FLAGS_ANONYMOUS = 20,
    MMAP_FLAGS_GROWSDOWN = 256,
    MMAP_FLAGS_DENY_WRITE = 2048,
    MMAP_FLAGS_EXECUTABLE = 4096,
    MMAP_FLAGS_LOCKED = 8192,
    MMAP_FLAGS_NO_RESERVE = 16384,
    MMAP_FLAGS_POPULATE = 32768,
    MMAP_FLAGS_NON_BLOCK = 65536,
}

MemmapProtection :: enum {
    MMAP_PROT_NONE = 0,
    MMAP_PROT_READ = 1,
    MMAP_PROT_WRITE = 2,
    MMAP_PROT_EXEC = 4,
    MMAP_PROT_GROSDOWN = 16777216,
    MMAP_PROT_GROWSUP = 33554432,
}

BLKMetadata :: struct {
    size: mut u64,
    next: mut *BLKMetadata,
    free: mut bool,
    mmap: mut bool,
}

_G_brkp :: mut* void = null;
_G_bhead :: mut* BLKMetadata = null;

exit :: (code: s64) -> void {
    asm {
        "movq #0, %rdi"
        "movq $60, %rax"
        "syscall"
        :
        : "r" (code)
        : "rdi", "rax"
    };
}

brk :: (addr: *void) -> s64 {
    let new: mut *void;

    asm {
        "movq $12, %rax"
        "movq #1, %rdi"
        "syscall"
        "movq %rax, #0"
        : "|m" (new)
        : "r" (addr)
        : "rax", "rdi"
    };

    if new {
        ret 0;
    } else {
        ret -1;
    }
}

sbrk :: (inc: u64) -> *void {
    if !_G_brkp {
        asm {
            "movq $12, %rax"
            "movq $0, %rdi"
            "syscall"
            "movq %rax, #0"
            : "|m" (_G_brkp)
            :
            : "rax", "rdi"
        };

        if !_G_brkp {
            ret cast<*char>(-1);
        }
    }

    if inc == 0 {
        ret _G_brkp;
    }

    let old: *void = _G_brkp;
    let new: *void = cast<*char>(_G_brkp) + inc;

    if brk(new) == -1 {
        ret cast<*char>(-1);
    }

    _G_brkp = new;
    ret _G_brkp;
}

mmap :: (addr: *void, len: u64, prot: MemmapProtection, flags: MemmapFlags, 
         fd: s64, offset: u64) -> *void {
    let ptr: mut *void;

    asm {
        "movq $9, %rax"
        "movq #1, %rdi"
        "movq #2, %rsi"
        "movq #3, %rdx"
        "movq #4, %rcx"
        "movq #5, %r8"
        "movq #6, %r9"
        "syscall"
        "movq %rax, #0"
        : "|m" (ptr)
        : "r" (addr), "r" (len), "r" (prot), "r" (flags), "r" (fd), "r" (offset)
        : "rax", "rdi", "rsi", "rdi", "rcx", "r8", "r9"
    };

    ret ptr;
}

write :: (fd: u32, buf: *char, count: u64) -> void {
    asm {
        "movq #2, %rdx"
        "movq #1, %rsi"
        "movl #0, %edi"
        "movq $1, %rax"
        "syscall"
        :
        : "r" (fd), "r" (buf), "r" (count)
        : "rdx", "rsi", "rdi", "rax"
    };
}

strlen :: (str: *char) -> u64 {
    let len: mut u64 = 0;
    while str[len++] != '\0';
    ret len;
}

print :: (str: *char) -> void {
    write(1, str, strlen(str));
}

main :: () -> s64 {
    print("Hello, world!\n");
    ret 0;
}
